"""Host writer orchestrator built on optical_storage primitives.

This module provides a small convenience wrapper to:
- optionally scramble input bytes,
- write them into a voxel lattice using :class:`LaserWriter`, and
- read them back using :class:`LaserReader` for verification.

It intentionally avoids adding heavyweight dependencies or crypto; the
scrambler implemented here is a simple XOR with a PRBS generated by a
deterministic LFSR to decorrelate patterns.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Optional, Sequence, Tuple

from optical_storage.reader import LaserReader, ReadResult
from optical_storage.storage_pattern import StoragePattern
from optical_storage.writer import LaserWriter
from optical_storage.voxel import Voxel


def _lfsr_prbs(length: int, seed: int = 0xACE1) -> bytes:
    """Generate a simple PRBS stream using a 16-bit LFSR.

    Feedback polynomial: x^16 + x^14 + x^13 + x^11 + 1 (0xB400 taps)
    Returns exactly ``length`` bytes.
    """
    state = seed & 0xFFFF or 0x1
    out = bytearray()
    for _ in range(length):
        byte = 0
        for bit in range(8):
            lsb = state & 1
            byte |= (lsb << bit)
            state >>= 1
            if lsb:
                state ^= 0xB400
        out.append(byte)
    return bytes(out)


def _xor_bytes(data: bytes, mask: bytes) -> bytes:
    return bytes(d ^ m for d, m in zip(data, mask))


@dataclass
class HostReadback:
    data: bytes
    read_result: ReadResult
    pattern: StoragePattern


@dataclass
class HostWriter:
    """Minimal host-side orchestrator for writing and verifying data.

    Parameters mirror :class:`LaserWriter` with an extra ``scramble`` flag.
    """

    grid_size: Tuple[int, int, int] = (64, 64, 32)
    voxel_pitch: Tuple[float, float, float] = (5.0, 5.0, 20.0)
    intensity_levels: int = 16
    polarization_states: int = 8
    intensity_range: Tuple[float, float] = (0.15, 1.0)
    polarization_range: Tuple[float, float] = (0.0, 3.141592653589793)
    scramble: bool = True

    def _build_writer(self) -> LaserWriter:
        return LaserWriter(
            grid_size=self.grid_size,
            voxel_pitch=self.voxel_pitch,
            intensity_levels=self.intensity_levels,
            polarization_states=self.polarization_states,
            intensity_range=self.intensity_range,
            polarization_range=self.polarization_range,
        )

    def package(self, data: bytes) -> bytes:
        """Apply light-weight scrambling to decorrelate bit patterns."""
        if not self.scramble or not data:
            return data
        mask = _lfsr_prbs(len(data))
        return _xor_bytes(data, mask)

    def write(self, data: bytes) -> StoragePattern:
        """Scramble and write data into a storage pattern with capacity guard."""
        writer = self._build_writer()
        packaged = self.package(data)
        # The LaserWriter already validates capacity internally.
        return writer.write(packaged)

    def verify(
        self,
        pattern: StoragePattern,
        voxels: Optional[int] = None,
        voxels_override: Optional[Sequence[Voxel]] = None,
    ) -> HostReadback:
        """Read back data and descramble to return the original payload.

        ``voxels`` may limit the number of voxels read (for partial read tests).
        """
        reader = LaserReader(pattern)
        if voxels_override is not None:
            seq: Sequence[Voxel] = list(voxels_override)
        else:
            seq = pattern.voxels if voxels is None else pattern.voxels[: max(0, int(voxels))]
        rr = reader.read(seq)
        out = rr.data
        if self.scramble and out:
            out = _xor_bytes(out, _lfsr_prbs(len(out)))
        return HostReadback(data=out, read_result=rr, pattern=pattern)
